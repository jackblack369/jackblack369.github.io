<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[words fragment]]></title>
    <url>%2F2018%2F08%2F28%2Fwords%20fragment%2F</url>
    <content type="text"><![CDATA[英文碎片 Life is measured by thought and action, not by time. Books and friends should be few but good. Don’t give your past the power to define your future. People will forget what you said, people will forget what you did, but people will never forget how you made them feel. Success isn’t about being the best. It’s about always getting better. Be yourself. Everyone else is already taken. It’s kind of fun to do the impossible. “Simplicity is the ultimate sophistication.”Leonardo da Vinci Build a dream and the dream will build you. Always make a total effort, even when the odds are against you. You can, you should, and if you’re brave enough to start, you will. Never give up, for that is just the place and time that the tide will turn. Awareness is the greatest agent for change. Nothing can dim the light which shines from within. Our dreams can come true if we have the courage to pursue them. Patience and perseverance have a magical effect before which difficulties disappear and obstacles vanish. What you do makes a difference, and you have to decide what kind of difference you want to make. The thing that is really hard, and really amazing, is giving up on being perfect and beginning the work of becoming yourself. You are what you do, not what you say you’ll do. This is the real secret to life—to be completely engaged with what you are doing in the here and now. And instead of calling it work, realize it is play. I am strong because I’ve been weak. I am fearless because I’ve been afraid. I am wise because I’ve been foolish. Every moment you live in the past is a moment you waste in the present. Some changes look negative on the surface, but you will soon realize that space is being created in your life for something new to emerge. The world breaks everyone and afterward many are strong at the broken places. Don’t bury your failures. Let them inspire you. Whether you think you can or you think you can’t, you are right. “An investment in knowledge pays the best interest.”Benjamin Franklin 中文碎片 some body 谎言不攻不破 没经历过事，成不了大事 母亲给了你生命，也会把生命给你名人碎片 极深的暴力当中隐藏着极致的温柔 (北野武) 其它碎片 arithmetic addition, subtraction, multiplication and division calculations Promise(承诺)、Earnest(诚挚)、Respect(尊重)、Forgiveness(宽容)、Enioy(享受)、Cherish(珍惜)、Trust(信任) In any case, measure, don’t guess! Only a measurement will tell you if the parallelism is worth it or not.(from stack overflow’s someone)]]></content>
      <categories>
        <category>fragement</category>
      </categories>
      <tags>
        <tag>words</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows snippet]]></title>
    <url>%2F2018%2F05%2F22%2Fwindows%20snippet%2F</url>
    <content type="text"><![CDATA[进程操作 netstat -aon|findstr “8080” TCP 127.0.0.1:80 0.0.0.0:0 LISTENING 2448端口被进程号为2448的进程占用，继续执行下面命令： tasklist|findstr “2448” thread.exe 2016 Console 0 16,064 K 很清楚，thread占用了你的端口,Kill it taskkill -F -PID 2448 如果第二步查不到，那就开任务管理器，进程—查看—选择列—pid（进程位标识符）打个勾就可以了]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[design pattern]]></title>
    <url>%2F2018%2F05%2F01%2Fdesign-pattern%20build%2F</url>
    <content type="text"><![CDATA[build1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Computerpublic class Computer &#123;//required parametersprivate String HDD;private String RAM;//optional parametersprivate boolean isGraphicsCardEnabled;private boolean isBluetoothEnabled;public String getHDD() &#123; return HDD;&#125;public String getRAM() &#123; return RAM;&#125;public boolean isGraphicsCardEnabled() &#123; return isGraphicsCardEnabled;&#125;public boolean isBluetoothEnabled() &#123; return isBluetoothEnabled;&#125;private Computer(ComputerBuilder builder) &#123; this.HDD=builder.HDD; this.RAM=builder.RAM; this.isGraphicsCardEnabled=builder.isGraphicsCardEnabled; this.isBluetoothEnabled=builder.isBluetoothEnabled;&#125;//Builder Classpublic static class ComputerBuilder&#123; // required parameters private String HDD; private String RAM; // optional parameters private boolean isGraphicsCardEnabled; private boolean isBluetoothEnabled; public ComputerBuilder(String hdd, String ram)&#123; this.HDD=hdd; this.RAM=ram; &#125; public ComputerBuilder setGraphicsCardEnabled(boolean isGraphicsCardEnabled) &#123; this.isGraphicsCardEnabled = isGraphicsCardEnabled; return this; &#125; public ComputerBuilder setBluetoothEnabled(boolean isBluetoothEnabled) &#123; this.isBluetoothEnabled = isBluetoothEnabled; return this; &#125; public Computer build()&#123; return new Computer(this); &#125;&#125;&#125;//ComputerBuilderimport com.journaldev.design.builder.Computer;public class TestBuilderPattern &#123;public static void main(String[] args) &#123; //Using builder to get the object in a single line of code and //without any inconsistent state or arguments management issues Computer comp = new Computer.ComputerBuilder( "500 GB", "2 GB").setBluetoothEnabled(true) .setGraphicsCardEnabled(true).build();&#125;&#125; `]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate snippet]]></title>
    <url>%2F2018%2F05%2F01%2Fhibernate%20snippet%2F</url>
    <content type="text"><![CDATA[ORM is an acronym for Object/Relational mapping. It is a programming strategy to map object with the data stored in the database. It simplifies data creation, data manipulation, and data access. The advantages of using ORM over JDBC Application development is fast. Management of transaction. Generates key automatically. Details of SQL queries are hidden. Hibernate Architecture Java application layer Hibernate framework layer Backhand api layer Database layer JDBC (Java Database Connectivity) JTA (Java Transaction API) JNDI (Java Naming Directory Interface) Elements of Hibernate Architecture SessionFactory SessionFactory is a thread-safe object, many threads cannot access it simultaneously. Session It maintains a connection between the hibernate application and database.It provides methods to store, update, delete or fetch data from the database such as persist(), update(), delete(), load(), get() etc. Session is not a thread-safe object, many threads can access it simultaneously. In other words, you can share it between threads. Transaction ConnectionProvider TransactionFactory About SQL SQL query created in Hibernate Session.createSQLQuery 123Session.createSQLQuery()//The method createSQLQuery() creates Query object using the native SQL syntax. Query query = session.createSQLQuery("Select * from Student"); HQL query Session.createQuery 123Session.createQuery()//The method createQuery() creates Query object using the HQL syntax. Query query = session.createQuery("from Student s where s.name like 'k%'"); criteria query Session.createCriteria 123Session.createCriteria()//The method createCriteria() creates Criteria object for setting the query parameters. This is more useful feature for those who don't want to write the query in hand. You can specify any type of complicated syntax using the Criteria API.Criteria criteria = session.createCriteria(Student.class); HQL vs Criteria HQL is to perform both select and non-select operations on the data, but Criteria is only for selecting the data, we cannot perform non-select operations using criteria HQL is suitable for executing Static Queries, where as Criteria is suitable for executing Dynamic Queries HQL doesn’t support pagination concept, but we can achieve pagination with Criteria Criteria used to take more time to execute then HQL With Criteria we are safe with SQL Injection because of its dynamic query generation but in HQL as your queries are either fixed or parametrized, there is no safe from SQL Injection. types of association mapping One to One One to Many Many to One Many to Many]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis snippet]]></title>
    <url>%2F2018%2F02%2F16%2Fredis%20snippet%2F</url>
    <content type="text"><![CDATA[知识点 show all keys KEYS * Delete All Keys In Redis 123456Delete all keys from all Redis databases: `$ redis-cli FLUSHALL` Delete all keys of the currently selected Redis database: `$ redis-cli FLUSHDB` Delete all keys of the specified Redis database: `$ redis-cli -n &lt;database_number&gt; FLUSHDB` 问题解决 RedisConnectionFailureException 123redis.conf中默认的是bind 127.0.0.1，需要将这段注释设置protected-mode no，因为如果是yes的话，只能进行本地访问。如果设置了密码和bind这个可以开启，如果没有设置，这个属性可以设置为no即可。daemonize yes表示后台运行 需要安装gcc make时，提示fatal error: jemalloc/jemalloc.h: No such file or directory 123456解决： cd src/depsmake hiredis jemalloc linenoise lua geohash-intcd ..makesudo make install 自定义配置redis server涉及到的目录或文件有 12345 1.配置文件 /etc/redis/xxxx.conf 2.日志、数据文件 /data/redis/xxxx 3.启动脚本 /etc/init.d/redis_xxxx 客户端启动时 redis-cli -p xxxx]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java design pattern]]></title>
    <url>%2F2017%2F12%2F20%2Fjava%20design%20pattern%2F</url>
    <content type="text"><![CDATA[Creational Design PatternsSingleton different approaches to implement: Private constructor to restrict instantiation of the class from other classes. Private static variable of the same class that is the only instance of the class. Public static method that returns the instance of the class, this is the global access point for outer world to get the instance of the singleton class. design concerns with the implementation Eager initialization Static block initialization Lazy Initialization Thread Safe Singleton Bill Pugh Singleton Implementation Using Reflection to destroy Singleton Pattern Enum Singleton Serialization and Singleton Factory Factory design pattern provides approach to code for interface rather than implementation. Factory pattern removes the instantiation of actual implementation classes from client code. Factory pattern makes our code more robust, less coupled and easy to extend. For example, we can easily change PC class implementation because client program is unaware of this. Factory pattern provides abstraction between implementation and client classes through inheritance. Abstract Factory Abstract Factory design pattern provides approach to code for interface rather than implementation. Abstract Factory pattern is “factory of factories” and can be easily extended to accommodate more products, for example we can add another sub-class Laptop and a factory LaptopFactory. Abstract Factory pattern is robust and avoid conditional logic of Factory pattern. Builder Builder pattern solves the issue with large number of optional parameters and inconsistent state by providing a way to build the object step-by-step and provide a method that will actually return the final Object. Prototype Prototype design pattern is used when the Object creation is a costly affair and requires a lot of time and resources and you have a similar object already existing.Prototype pattern provides a mechanism to copy the original object to a new object and then modify it according to our needs. Prototype design pattern uses java cloning to copy the object. Structural Design PatternsAdapter Adapter design pattern is one of the structural design pattern and its used so that two unrelated interfaces can work together. The object that joins these unrelated interface is called an Adapter. Composite Composite design pattern is used when we have to represent a part-whole hierarchy. Proxy Proxy design pattern common uses are to control access or to provide a wrapper implementation for better performance. Flyweight Use sharing to support large numbers of fine-grained objects efficiently Facade Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use. Bridge Decouple an abstraction from its implementation so that the two can vary independently. Decorator Decorator design pattern is helpful in providing runtime modification abilities and hence more flexible. Its easy to maintain and extend when the number of choices are more. The disadvantage of decorator design pattern is that it uses a lot of similar kind of objects (decorators). Behavioral Design PatternsTemplate Method Template method should consists of certain steps whose order is fixed and for some of the methods, implementation differs from base class to subclass. Template method should be final. Most of the times, subclasses calls methods from super class but in template pattern, superclass template method calls methods from subclasses, this is known as Hollywood Principle – “don’t call us, we’ll call you.”. Methods in base class with default implementation are referred as Hooks and they are intended to be overridden by subclasses, if you want some of the methods to be not overridden, you can make them final, for example in our case we can make buildFoundation() method final because if we don’t want subclasses to override it. Media Allows loose coupling by encapsulating the way disparate sets of objects interact and communicate with each other. Allows for the actions of each object set to vary independently of one another.]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[neo4j snippet]]></title>
    <url>%2F2017%2F11%2F21%2Fneo4j%20snippet%2F</url>
    <content type="text"><![CDATA[cypher语法对大小写敏感，注意属性的大小写 导入csv出现乱码时，需要通过记事本更改编码格式，如果文本过大，需要一段一段的复制粘贴到新文本中，且以UTF-8格式编码 MERGE命令是CREATE命令和MATCH命令的组合。MERGE = CREATE + MATCH 问题1. 现象： 在外部处理csv数据，导入服务器，然后load csv到neo4j中，可能由于文件所属问题，不能成功导入csv，提示Couldn&#39;t load the external resource的错误。 解决：复制可以导入的csv文件为副本，把待导入的数据粘贴到副本中，load csv副本即可 2. 现象： 在外部处理csv数据，进行merge操作的时候，提示cannot merge using null property value for uid的错误。 解决：经发现，是由于指令中的属性拼写错误，导致Neo.ClientError.Statement.SemanticError的错误，例如把sfzh拼写成sfhm。 3. 现象： 大量数据的导入问题。 解决：需使用https://neo4j.com/docs/operations-manual/current/tools/import/ 注意：Import tool is only for newly created databases. You can use LOAD CSV cypher command to load into an existing database.也就是说neo4j-admin import只会在新建数据库的时候会用到]]></content>
      <categories>
        <category>neo4j</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java stream]]></title>
    <url>%2F2017%2F10%2F16%2Fjava%20stream%2F</url>
    <content type="text"><![CDATA[Creating Java Streams We can use Stream.of() to create a stream from similar type of data. For example, we can create Java Stream of integers from a group of int or Integer objects. 1Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4); We can use Stream.of() with an array of Objects to return the stream. Note that it doesn’t support autoboxing, so we can’t pass primitive type array. 12345Stream&lt;Integer&gt; stream = Stream.of(new Integer[]&#123;1,2,3,4&#125;); //works fineStream&lt;Integer&gt; stream1 = Stream.of(new int[]&#123;1,2,3,4&#125;); //Compile time error, Type mismatch: cannot convert from Stream&lt;int[]&gt; to Stream&lt;Integer&gt; We can use Collection stream() to create sequential stream and parallelStream() to create parallel stream. 12345678List&lt;Integer&gt; myList = new ArrayList&lt;&gt;();for(int i=0; i&lt;100; i++) myList.add(i); //sequential streamStream&lt;Integer&gt; sequentialStream = myList.stream(); //parallel streamStream&lt;Integer&gt; parallelStream = myList.parallelStream(); We can use Stream.generate() and Stream.iterate() methods to create Stream. 12Stream&lt;String&gt; stream1 = Stream.generate(() -&gt; &#123;return "abc";&#125;);Stream&lt;String&gt; stream2 = Stream.iterate("abc", (i) -&gt; i); Using Arrays.stream() and String.chars() methods. 12LongStream is = Arrays.stream(new long[]&#123;1,2,3,4&#125;);IntStream is2 = "abc".chars(); Converting Java Stream to Collection or Array We can use java Stream collect() method to get List, Map or Set from stream. 1234567Stream&lt;Integer&gt; intStream = Stream.of(1,2,3,4);List&lt;Integer&gt; intList = intStream.collect(Collectors.toList());System.out.println(intList); //prints [1, 2, 3, 4]intStream = Stream.of(1,2,3,4); //stream is closed, so we need to create it againMap&lt;Integer,Integer&gt; intMap = intStream.collect(Collectors.toMap(i -&gt; i, i -&gt; i+10));System.out.println(intMap); //prints &#123;1=11, 2=12, 3=13, 4=14&#125; We can use stream toArray() method to create an array from the stream. 123Stream&lt;Integer&gt; intStream = Stream.of(1,2,3,4);Integer[] intArray = intStream.toArray(Integer[]::new);System.out.println(Arrays.toString(intArray)); //prints [1, 2, 3, 4] Java Stream Intermediate Operations Stream filter() : We can use filter() method to test stream elements for a condition and generate filtered list. 12345678List&lt;Integer&gt; myList = new ArrayList&lt;&gt;();for(int i=0; i&lt;100; i++) myList.add(i);Stream&lt;Integer&gt; sequentialStream = myList.stream();Stream&lt;Integer&gt; highNums = sequentialStream.filter(p -&gt; p &gt; 90); //filter numbers greater than 90System.out.print("High Nums greater than 90=");highNums.forEach(p -&gt; System.out.print(p+" "));//prints "High Nums greater than 90=91 92 93 94 95 96 97 98 99 " Stream map() : We can use map() to apply functions to an stream. Let’s see how we can use it to apply upper case function to a list of Strings. 12345Stream&lt;String&gt; names = Stream.of("aBc", "d", "ef");System.out.println(names.map(s -&gt; &#123; return s.toUpperCase(); &#125;).collect(Collectors.toList()));//prints [ABC, D, EF] Stream sorted() : We can use sorted() to sort the stream elements by passing Comparator argument. 1234567Stream&lt;String&gt; names2 = Stream.of("aBc", "d", "ef", "123456");List&lt;String&gt; reverseSorted = names2.sorted(Comparator.reverseOrder()).collect(Collectors.toList());System.out.println(reverseSorted); // [ef, d, aBc, 123456]Stream&lt;String&gt; names3 = Stream.of("aBc", "d", "ef", "123456");List&lt;String&gt; naturalSorted = names3.sorted().collect(Collectors.toList());System.out.println(naturalSorted); //[123456, aBc, d, ef] Stream flatMap() : We can use flatMap() to create a stream from the stream of list. Let’s see a simple example to clear this doubt. 123456789Stream&lt;List&lt;String&gt;&gt; namesOriginalList = Stream.of( Arrays.asList("Pankaj"), Arrays.asList("David", "Lisa"), Arrays.asList("Amit"));//flat the stream from List&lt;String&gt; to String streamStream&lt;String&gt; flatStream = namesOriginalList .flatMap(strList -&gt; strList.stream());flatStream.forEach(System.out::println); Java Stream Terminal Operations Stream reduce() example: We can use reduce() to perform a reduction on the elements of the stream, using an associative accumulation function, and return an Optional. Let’s see how we can use it multiply the integers in a stream. 1234Stream&lt;Integer&gt; numbers = Stream.of(1,2,3,4,5); Optional&lt;Integer&gt; intOptional = numbers.reduce((i,j) -&gt; &#123;return i*j;&#125;);if(intOptional.isPresent()) System.out.println("Multiplication = "+intOptional.get()); //120 Stream count() example: We can use this terminal operation to count the number of items in the stream. 12Stream&lt;Integer&gt; numbers1 = Stream.of(1,2,3,4,5);System.out.println("Number of elements in stream="+numbers1.count()); //5 Stream forEach() example: This can be used for iterating over the stream. We can use this in place of iterator. Let’s see how to use it for printing all the elements of the stream. 12Stream&lt;Integer&gt; numbers2 = Stream.of(1,2,3,4,5);numbers2.forEach(i -&gt; System.out.print(i+",")); //1,2,3,4,5, Stream match() examples: Let’s see some of the examples for matching methods in Stream API. 1234567891011Stream&lt;Integer&gt; numbers3 = Stream.of(1,2,3,4,5);System.out.println("Stream contains 4? "+numbers3.anyMatch(i -&gt; i==4));//Stream contains 4? trueStream&lt;Integer&gt; numbers4 = Stream.of(1,2,3,4,5);System.out.println("Stream contains all elements less than 10? "+numbers4.allMatch(i -&gt; i&lt;10));//Stream contains all elements less than 10? trueStream&lt;Integer&gt; numbers5 = Stream.of(1,2,3,4,5);System.out.println("Stream doesn't contain 10? "+numbers5.noneMatch(i -&gt; i==10));//Stream doesn't contain 10? true Stream findFirst() :This is a short circuiting terminal operation, let’s see how we can use it to find the first string from a stream starting with D. 12345Stream&lt;String&gt; names4 = Stream.of("Pankaj","Amit","David", "Lisa");Optional&lt;String&gt; firstNameWithD = names4.filter(i -&gt; i.startsWith("D")).findFirst();if(firstNameWithD.isPresent())&#123; System.out.println("First Name starting with D="+firstNameWithD.get()); //David&#125; some example123456//merge collectionList&lt;String&gt; resultPersonnos = Stream.of(list1, list2) .flatMap(Collection::stream) .distinct() .sorted() .collect(Collectors.toList());]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word record]]></title>
    <url>%2F2017%2F05%2F30%2Fwork%20record%2F</url>
    <content type="text"><![CDATA[关于代码编译的事情 问题 由于一些配置项写在统一的配置文档中，代码从配置文件中读取确定的配置项；此时操作的文本路径是要追加上根目录的路径，然而开发环境和生成环境是不一样的。项目在打包的过程中，就确定了文本路径，这样导致两边环境的配置文档读取结果不一致。 解决办法 把文件路径精确写入 在生成环境下编译代码 关于读取数据量大的excel文件 问题 项目部署到tomcat中，每次读取大于1M的文件时，会停滞在org.apache.poi.ss.usermodel.Workbook workbook = new XSSFWorkbook(is);,直到tomcat出现报错信息java.lang.OutOfMemoryError: Java heap space,即java虚拟机堆溢出的错误。 现象描述 手动设置Xms,Xmx的大小，在/bin/catalina.bat（windows环境）配置中，添加JAVA_OPTS=&quot;-server -Xms10G -Xmx20G&quot;,不知道什么原因，重启服务，仍旧报一样的错。（当我在自己电脑上运行程序，操作同样大小的文档时，也没有报错，何况自己电脑才8G内存，远不及服务器，再则就是自身电脑tomcat的配置也是默认的） 内存总体分为年轻代(young),老年代(old),永久代(permanent),如图]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[other snippet]]></title>
    <url>%2F2017%2F02%2F16%2Fother%20tips%2F</url>
    <content type="text"><![CDATA[other snippetgenerate code based proto fileprotoc --proto_path=扫描目录 --java_out=代码生成目录 proto文件目录 protoc –proto_path=src –java_out=build/gen src/foo.proto Spring provides three way of scheduling: @Scheduled Via Quartz Via JDK Timer one word \x对应的是UTF-8编码的数据]]></content>
      <categories>
        <category>fragment</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html snippet]]></title>
    <url>%2F2017%2F02%2F10%2Fhtml%20snippet%2F</url>
    <content type="text"><![CDATA[知识点 chrome页面跳转，需要使用 i 标签，不能使用 button 标签，因为在button的点击事件中，window.location.href不起作用。（但firefox起作用）]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat snippet]]></title>
    <url>%2F2016%2F12%2F16%2Ftomcat%20snippet%2F</url>
    <content type="text"><![CDATA[配置项 项目部署到linux的tomcat中，验证码在页面中刷新不了，需要修改catalina.sh,添加JAVA_OPTS=&quot;$JAVA_OPTS -Djava.awt.headless=true&quot;配置 设置虚拟路径的两种方法 使用tomcat自身设置虚拟路径 在tomcat的server.xml配置文件中，配置context标签 Context标签中的相关属性： path: 指定访问该web应用的URL入口，即虚拟文件目录 docBase:为访问的真实路径 reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动， 如果监测到有class文件被更新的，服务器会自动重新加载Web应用。 如果这事使用idea启动项目，需要将Deploy applications configured in Tomcat instance勾上 单独设置IDEA进行设置虚拟路径 上图的中Deploy applications configured in Tomcat instance不要勾上 选中edit configurations，点击加号按钮，选择实际路径，并在Appication context中填写虚拟路径。 设置URL请求参数长度 问题描述 post请求，本身请求参数无大小限制，但是一般的服务器像tomcat都有默认大小，如果传输的参数超过了默认大小，则会报错http post request header is too large 解决办法 在server.xml中&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;，添加设置项maxHttpHeaderSize =&quot;102400&quot;]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring snippet]]></title>
    <url>%2F2016%2F10%2F16%2Fspring%20snippet%2F</url>
    <content type="text"><![CDATA[知识点传JSON字符串+@RequestBody接收 前端 12345678910111213141516171819202122function icheckDelete(url)&#123; var parms = &#123; list : array //这是个数组 &#125;; $.ajax(&#123; dataType: "JSON", contentType:'application/json;charset=UTF-8',//关键是要加上这行 traditional:true,//这使json格式的字符不会被转码 data: JSON.stringify(parms), type: "DELETE", timeout: 20000, url: url, success : function () &#123; alert("删除成功！"); &#125;, error : function (data)&#123; alert(data.responseText); &#125; &#125;);&#125; 后端 12345678910Controller:@RequestMapping(value = "deleteList", method = RequestMethod.DELETE)@ResponseBodypublic String delete(@RequestBody DeleteListRequest request) throws WebTransException&#123; /* 逻辑代码 */ return "success";&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Concept of The Day]]></title>
    <url>%2F2016%2F10%2F16%2FJava%20Concept%20of%20The%20Day%2F</url>
    <content type="text"><![CDATA[Stack is used only for execution purpose. Heap is used for storage purpose.Non-Static Members And Their Memory Management In Java Non-Static variables and Non-Static methods are non-static components of a class. These are also called instance components of a class. Non-static components are stored inside the object memory. Each object will have their own copy of non-static components. But, static components are common to all objects of that class.IIB-Instance Initialization Block IIB is used to initialize instance variables or non-static variables. IIB blocks will not be called from the constructor in which this() statement is written as a first statement. super and this keywords in java super class constructor is called by super() calling statement. You can’t use super() calling statement outside the constructor. By default, super() calling statement is the first statement in any constructor. this() is the calling statement to same class constructor. It must be used within constructor only. If it is used, it must be the first statement in the constructor. You can’t use super and this keywords in a static method and in a static initialization block even though you are referring static members.10 Points Every Java Programmer Should Know About final keyword in java Any class or any method can be either abstract or final but not both. abstract and final are totally opposite. Because, abstract class or abstract method must be implemented or modified in the sub classes but final does not allow this. This creates an ambiguity. The global variable which is declared as final and static remains unchanged for the whole execution. Because, Static members are stored in the class memory and they are loaded only once in the whole execution. They are common to all objects of the class. If you declare static variables as final, any of the objects can’t change their value as it is final. Therefore, variables declared as final and static are sometimes referred to as Constants. All fields of interfaces are referred as constants, because they are final and static by default.Garbage Collection And finalize() method In Java Whenever you run a java program, JVM creates three threads. 1) main thread 2) Thread Scheduler 3) Garbage Collector Thread. In these three threads, main thread is a user thread and remaining two are daemon threads which run in background.Access Modifiers In Java Class can not be a private except inner classes. Inner classes are nothing but again members of outer class. So members of a class (field, method, constructor and inner class) can be private but not the class itself.What Are Access And Non-Access Modifiers In Java?Type Casting In JavaPlease note that by using casting, data can not be modified but only type of data can be modified. Primitive Casting. memory size byte &lt; short &lt; int &lt; long &lt; float &lt; double. Auto Widening Explicit Narrowing Derived Casting Auto-up Casting Explicit Down CastingAbstraction In Java Abstract classes contain abstract methods (you can refer them as ideas) so that they can be implemented in sub classes according to their requirements. They are also called as incomplete classes as they have some unimplemented abstract methods(ideas).Interfaces In Java Interfaces in java are very much similar to abstract classes but interfaces contain only abstract methods (you can refer to them as only ideas). Abstract classes may contain both abstract methods as well as concrete methods. But interfaces must contain only abstract methods. Concrete methods are not allowed in interfaces. Therefore, Interfaces show 100% abstractness.Auto-Widening Vs Auto-Boxing Vs Auto-UpCasting In JavaException Handingjava.lang.Throwable is the super class of all errors and exceptions in java. java.lang.Error class represents the errors which are mainly caused by the environment in which application is running. For example, OutOfMemoryError occurs when JVM runs out of memory or StackOverflowError occurs when stack overflows. Where as java.lang.Exception class represents the exceptions which are mainly caused by the application itself. For example, NullPointerException occurs when an application tries to access null object or ClassCastException occurs when an application tries to cast incompatible class types. Arrays Array can hold the references to any type of objects. It is important to note that array can contain only references to the objects, not the objects itself. Threads Processes and threads can be diagrammatically represented as this User threads are threads which are created by the application or user. Daemon threads are threads which are mostly created by the JVM. There are three constant fields in java.lang.Thread class related to priority of a thread. They are, 123 MIN_PRIORITY —&gt; It defines the lowest priority that a thread can have and It’s value is 1.NORM_PRIORITY —&gt; It defines the normal priority that a thread can have and it’s value is 5.MAX_PRIORITY —&gt; It defines the highest priority that a thread can have and it’s value is 10. The priority of a main thread, if explicitly not set, is always 5 i.e NORM_PRIORITY. avoid thread interference 123456 By declaring the method as synchronized.By declaring the variables as final.By declaring the variable as volatile.By creating the immutable objects.By using Atomic operations.By restricting the access to same object by multiple threads. The Logic Behind The Synchronization In Java : 123456 The synchronization in java is built around an entity called object lock or monitor. Here is the brief description about lock or monitor.- Whenever an object is created to any class, an object lock is created and is stored inside the object.- One object will have only one object lock associated with it.- Any thread wants to enter into synchronized methods or blocks of any object, they must acquire object lock associated with that object and release the lock after they are done with the execution.- The other threads which wants to enter into synchronized methods of that object have to wait until the currently executing thread releases the object lock.- To enter into static synchronized methods or blocks, threads have to acquire class lock associated with that class as static members are stored inside the class memory. mutex 123456789101112131415161718192021222324class Shared&#123; static void staticMethod() &#123; synchronized (Shared.class) &#123; //static synchronized block &#125; &#125; void NonStaticMethod() &#123; synchronized (this) &#123; //Non-static synchronized block &#125; &#125; void anotherNonStaticMethod() &#123; synchronized (new Shared()) &#123; //Non-static synchronized block &#125; &#125;&#125; 10 Points-To-Remember About Synchronization In Java : 123456789101. You can use synchronized keyword only with methods but not with variables, constructors, static initializer and instance initializers.2. Constructors, Static initializer and instance initializer can’t be declared with synchronized keyword, but they can contain synchronized blocks.3. Both static and non-static methods can use synchronized keyword. For static methods, thread need class level lock and for non-static methods, thread need object level lock.4. It is possible that both static synchronized and non-static synchronized methods can run simultaneously. Because, static methods need class level lock and non-static methods need object level lock.5. A method can contain any number of synchronized blocks. This is like synchronizing multiple parts of a method.6. Synchronization blocks can be nested.7. Lock acquired by the thread before executing a synchronized method or block must be released after the completion of execution, no matter whether execution is completed normally or abnormally (due to exceptions).8. Synchronization in java is Re-entrant in nature. A thread can not acquire a lock that is owned by another thread. But, a thread can acquire a lock that it already owns. That means if a synchronized method gives a call to another synchronized method which needs same lock, then currently executing thread can directly enter into that method or block without acquiring the lock.9. synchronized method or block is very slow. They decrease the performance of an application. So, special care need to be taken while using synchronization. Use synchronization only when you needed it the most.10. Use synchronized blocks instead of synchronized methods. Because, synchronizing some part of a method improves the performance than synchronizing the whole method. wait(), notify() and notifyAll() 123456789These methods are final methods of java.lang.Object class. That means every class in java will have these methods. Below is the method signatures of these methods.1. public final void wait() throws InterruptedExceptionThis method tells the currently executing thread to release the lock of this object and wait until some other thread acquires the same lock and notify it using either notify() or notifyAll() methods. This method throws InterruptedException if waiting thread is interrupted.2. public final void notify()This method wakes up one thread randomly that called wait() method on this object.3. public final void notifyAll()This method wakes up all the threads that called wait() method on this object. But, only one thread will acquire lock of this object depending upon the priority.Important Note : These three methods must be called within synchronized method or block. Any thread which calls these methods must have lock of that object. Some Things-To-Remember About wait(), notify() and notifyAll() : If a thread calls notify() method and more than one threads are waiting for the object lock, then only one thread will be notified randomly. When a thread calls notifyAll() method on an object, it notifies all the threads which are waiting for this object lock. But, only one thread will acquire this object lock depending upon priority. When you call sleep() method on a thread, thread goes to sleep with holding the object lock with it. But, if you call wait() method, thread releases the object lock and goes for sleep. This is the main difference between wait() and sleep() methods. wait(), notify() and notifyAll() are final methods of java.lang.Object class not java.lang.Thread class. wait(), notify() and notifyAll() – all these three methods throw IllegalMonitorStateException if the calling thread does not owns the object lock. wait() method is overloaded in Object class. There are two more wait() methods available in Object class. Thread Life Cycle OR Thread States In Java NEW, A thread will be in this state before calling start() method. RUNNABLE, A thread will be in this state after calling the start() method. BLOCKED, A thread will be in this state when a thread is waiting for object lock to enter into synchronized method/block or a thread will be in this state if deadlock occurs. WAITING, A thread will be in this state when wait() or join() method is called. TIMED_WAITING, A thread will be in this state when thread is sleeping. i.e A thread will be in this state when sleep() or wait() with timeOut or join() with timeOut is called. TERMINATED, A thread will be in this state once it finishes it’s execution. 7 Things Every Java Programmer Should Know About Threads In Java Runnable interface vs Thread class : I am of opinion that when multiple threads need to execute same task, then use Runnable interface. If multiple threads need to execute different tasks, then go for Thread class. Difference Between wait() and sleep() Methods In Java wait(): releases the lock or monitor sleep(): not releases the lock or monitor Extends Thread Vs Implements Runnable In JavaFrom the above all findings, it is clear that “Implements Runnable” is the preferred method to create the threads in java. How To Stop A Thread In Java One is using boolean variable and second one is using interrupt() method. In this post, we will discuss both of these methods. Difference Between notify And notifyAll In Java wait(), notify() and notifyAll() must be called within synchronized method or synchronized block. Difference Between BLOCKED Vs WAITING States In Java There are six thread states in java. They are NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING and TERMINATED. String strings are treated as objects. JVM allocates some memory specially meant for string literals. This part of the heap memory is called String Constant Pool.12345678String s1 = &quot;abc&quot;; String s2 = &quot;xyz&quot;;String s3 = &quot;123&quot;;String s4 = &quot;A&quot;; String s5 = new String(&quot;abc&quot;);char[] c = &#123;&apos;J&apos;, &apos;A&apos;, &apos;V&apos;, &apos;A&apos;&#125;;String s6 = new String(c);String s7 = new String(new StringBuffer()); String Constant Pool is allocated to an object depending upon it’s content. There will be no two objects in the pool having the same content. 1“When you create a string object using string literal, JVM first checks the content of to be created object. If there exist an object in the pool with the same content, then it returns the reference of that object. It doesn’t create new object. If the content is different from the existing objects then only it creates new object.” 1In simple words, there can not be two string objects with same content in the string constant pool. But, there can be two string objects with the same content in the heap memory. Immutability is the fundamental property of string objects. In whatever way you create the string objects, either using string literals or using new operator, they are immutable. Generic Defining Generic Class Generics Work Only With Derived Types Rules To Follow While Implementing Generic Interfaces Only generic classes can implement generic interfaces.class GenericClass&lt;T&gt; implements GenericInterface&lt;T&gt;-A normal class can implement a generic interface if type parameter of generic interface is a wrapper class. For example, below implementation of GenericInterface is legal. 123456interface GenericInterface&lt;Integer&gt;&#123; //Generic interface with Integer as type parameter&#125;class NormalClass implements GenericInterface&lt;Integer&gt;&#123; //Normal class implementing generic interface&#125; Class implementing generic interface at least must have same number and same type of parameters and at most can have any number and any type of parameters. 123class GenericClass2&lt;T, V&gt; implements GenericInterface&lt;T&gt;&#123; //Class with two type parameters&#125; Define Methods And Constructors As Generic Generic Methods:&lt;type-Parameters&gt; return_type method_name(parameter list) Constructors As Generics,As we all know that constructors are like methods but without return types Bounded Types the syntax for declaring Bounded type parameters.&lt;T extends SuperClass&gt;1public static &lt;T extends Number&gt; void printNumbers(T[] t) Wildcard arguments The syntax for declaring this type of wildcard arguments is:GenericType&lt;?&gt; To specify an upper bound for wildcards:GenericType&lt;? extends SuperClass&gt; specify a lower bound for wildcard argument using super clause:GenericType&lt;? super SubClass&gt; Type Erasure Collection Framework Collection Framework – Class Hierarchy All classes and interfaces related to Collection Framework are placed in java.util package. Collection Framework – Collection Interface equals() and hashcode() methods in the Collection interface are not the methods of java.lang.Object class. Because, interfaces does not inherit from Object class. Only classes in java are inherited from Object class. Any classes implementing Collection interface must provide their own version of equals() and hashcode() methods or they can retain default version inherited from Object class. Collection Framework – List Interface the class diagram of List interface： Collection Framework – The ArrayList Class Default initial capacity of an ArrayList is 10. the hierarchy diagram of ArrayList class. Properties Of ArrayList : Size of the ArrayList is not fixed. It can increase and decrease dynamically as we add or delete the elements. ArrayList can have any number of null elements. ArrayList can have duplicate elements. As ArrayList implements RandomAccess, you can get, set, insert and remove elements of the ArrayList from any arbitrary position. Differences Between Array Vs ArrayList In Java Array is static in nature,ArrayList is dynamic in nature when you try to add elements to ArrayList beyond its capacity, it creates the new array with increased size and copies the elements from old array to new array. if adding an element requires resizing of an ArrayList, then it gets slightly slower as it involves creating a new array in the background and copying all elements from old array to new array. Array can hold both primitive data types (int, float….) as well as objects. Where as ArrayList can hold only objects. If you try to insert primitive data into ArrayList, data is automatically boxed into corresponding wrapper class. ArrayList to Array,toArray() method returns an array containing all elements of the ArrayList.Object[] array = list.toArray(); Array To ArrayList: Arrays.asList() 12String[] array = new String[] &#123;&quot;ANDROID&quot;, &quot;JSP&quot;, &quot;JAVA&quot;, &quot;STRUTS&quot;, &quot;HADOOP&quot;, &quot;JSF&quot;&#125;;ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array)); Collection.addAll() 123String[] array = new String[] &#123;&quot;ANDROID&quot;, &quot;JSP&quot;, &quot;JAVA&quot;, &quot;STRUTS&quot;, &quot;HADOOP&quot;, &quot;JSF&quot;&#125;;ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); Collections.addAll(list, array); ArrayList.addAll() 123String[] array = new String[] &#123;&quot;ANDROID&quot;, &quot;JSP&quot;, &quot;JAVA&quot;, &quot;STRUTS&quot;, &quot;HADOOP&quot;, &quot;JSF&quot;&#125;;ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.addAll(Arrays.asList(array)); Using streams from java 8 12String[] array = new String[] &#123;&quot;ANDROID&quot;, &quot;JSP&quot;, &quot;JAVA&quot;, &quot;STRUTS&quot;, &quot;HADOOP&quot;, &quot;JSF&quot;&#125;;List&lt;Object&gt; list = Arrays.stream(array).collect(Collectors.toList()); Remove Duplicate Elements From ArrayList Using HashSet 12HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(listWithDuplicateElements);ArrayList&lt;String&gt; listWithoutDuplicateElements = new ArrayList&lt;String&gt;(set); Using LinkedHashSetLinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(listWithDuplicateElements); Collection Framework – The Vector Class Vector class is synchronized. All methods of Vector class are synchronized capacity of the vector will be doubled whenever size exceeds capacity. Why Not To Use Vector Class In Your Code you can achieve thread safe ArrayList by using synchronizedList() method of Collections class. Java Collection Framework – The LinkedList Class In general terms, LinkedList is a data structure where each element consist of three things. First one is the reference to previous element, second one is the actual value of the element and last one is the reference to next element. Collection Framework – The Queue Interface First-In-First-Out. You can’t add or get or set elements at an arbitrary position in the queues. Properties Of Queue : Null elements are not allowed in the queue. Queue can have duplicate elements. Unlike a normal list, queue is not random access. i.e you can’t set or insert or get elements at an arbitrary positions. In the Queue Interface, there are two methods to obtain and remove the elements from the head of the queue. They are poll() and remove(). The difference between them is, poll() returns null if the queue is empty and remove() throws an exception if the queue is empty. There are two methods in the Queue interface to obtain the elements but don’t remove. They are peek() and element(). peek() returns null if the queue is empty and element() throws an exception if the queue is empty. Collection Framework – The Deque Interface the hierarchy diagram of Deque interface： The main advantage of Deque is that you can use it as both Queue (FIFO) as well as Stack (LIFO). Deque is nothing but the double ended queue. That means, you can insert, retrieve and remove the elements from both the ends. Collection Framework – The Set Interface Order of elements in a set is implementation dependent. HashSet elements are ordered on hash code of elements. TreeSet elements are ordered according to supplied Comparator (If no Comparator is supplied, elements will be placed in ascending order) and LinkedHashSet maintains insertion order. The HashSet internally uses HashMap to store the objects. The elements you insert in HashSet will be stored as keys of that HashMap object and their values will be a constant called PRESENT. This constant is defined as private static final Object PRESENT = new Object() in the source code of HashSet class. HashSet can have maximum one null element. LinkedHashSet internally uses LinkedHashMap to store it’s elements just like HashSet which internally uses HashMap to store it’s elements. LinkedHashSet maintains insertion order. This is the main difference between LinkedHashSet and HashSet. SortedSet elements are sorted according to supplied Comparator. If you don’t mention any Comparator while creating a SortedSet, elements will be placed in ascending order. SortedSet Inserted elements must be of Comparable type and they must be mutually Comparable. Elements inserted in the TreeSet must be of Comparable type and elements must be mutually comparable. TreeSet internally uses TreeMap to store it’s elements just like HashSet and LinkedHashSet which use HashMap and LinkedHashMap respectively to store their elements. Java Collection Framework – The Map Interface Each key-value pairs of the map are stored as Map.Entry objects. Map.Entry is an inner interface of Map interface. HashMap doesn’t maintain any order of elements. LinkedHashMap maintains insertion order of elements. Where as TreeMap places the elements according to supplied Comparator. Default initial capacity of HashMap is 16. Hashing is nothing but the function or algorithm or method which when applied on any object/variable returns an unique integer value representing that object/variable. The capacity of an HashMap is the number of buckets in the hash table. The initial capacity is the capacity of an HashMap at the time of its creation. The default initial capacity of the HashMap is 24 i.e 16. The capacity of the HashMap is doubled each time it reaches the threshold. i.e the capacity is increased to 25=32, 26=64, 27=128….. when the threshold is reached. HashMap internally uses an array of Entry&lt;K, V&gt; objects to store the data. HashTable is a legacy class. It is almost considered as due for deprecation. Since JDK 1.5, ConcurrentHashMap is considered as better option than the HashTable. JDBC Java Database Connectivity API which is used by the java application to interact with the database. JDBC API not directly interacts with the database. It uses JDBC driver of that database to interact with the database. JDBC driver is a software component provided along with the database which is required by the JDBC API to interact with the database. Each database will have its own JDBC driver. In simple terms, JDBC drivers are nothing but the implementations of interfaces provided in the JDBC API (java.sql and javax.sql packages) with respect to a particular database. These implementations are bundled in a JAR file and supplied along with the database. These implementations are used by the JDBC API to interact with that database. Big O Notations Big O notations consist of O and an expression enclosed within ( ). Expression within ( ) represents the number of computations a particular algorithm has to perform to solve a given problem. O(1) represents an algorithm which has to perform exact one computation to solve a problem. O(1) represents an algorithm which takes same time to execute for any size of input data. In other words, O(1) denotes an algorithm which performance is not affected by the size of the input data. 123456789boolean isFirstElementZero(int[] inputData) &#123; if(inputData[0] == 0) &#123; return true; &#125; return false; &#125; O(N) represents an algorithm which has to perform ‘N’ computations to solve a problem. Where ‘N’ is the number of elements in input data. That means algorithm will take more time as number of elements in input data increases. In the other words, O(N) denotes an algorithm whose performance is directly proportional to size of the input data. 123456789101112boolean searchForElement(int[] inputData, int n) &#123; for (int i = 0; i &lt; inputData.length; i++) &#123; if(inputData[i] == n) &#123; return true; &#125; &#125; return false; &#125; O(N^2) denotes an algorithm which has to perform N^2 computations to solve a problem. Where N is the number of elements in input data. In the other words, O(N^2) represents an algorithm whose performance is directly proportional to square of the size of the input data. The algorithms which have nested iterations over the input data will give O(N^2) performance. Further deeper iterations over the input data will give O(N^3), O(N^4) and so on. 123456789101112131415boolean findDuplicates(int[] inputData)&#123; for (int i = 0; i &lt; inputData.length; i++) &#123; for (int j = 0; j &lt; inputData.length; j++) &#123; if(inputData[i] == inputData[j] &amp;&amp; i!=j) &#123; return true; &#125; &#125; &#125; return false;&#125; O(log N) represents an algorithm whose number of computations grows linearly as input data grows exponentially. i.e O(log N) represents the algorithms whose execution time grows linearly as input data grows exponentially. That means if an algorithm takes 1 second to compute 10 elements, then it will take 2 seconds to compute 100 elements, 3 seconds to compute 1000 elements and so on. The best example for O(log N) is binary search algorithm which uses divide and conquer rule to search for an element. O(2N) represents an algorithm whose execution time is doubled for every extra element in the input data. For example, if an algorithm takes 4 seconds to compute 2 elements, then it will take 8 seconds to compute 3 elements, 16 seconds for 4 elements, 32 seconds for 5 elements and so on. O(N!) represents an algorithm which has to perform N! computations to solve a problem. Where N is the number of elements in the input data. For example, if an algorithm takes 2 seconds to compute 2 elements, then it will take 6 seconds to compute 3 elements, 24 seconds to compute 4 elements and so on.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis snippet]]></title>
    <url>%2F2016%2F10%2F16%2Fmybatis%20snippet%2F</url>
    <content type="text"><![CDATA[知识点 about date jdbcType 12#&#123;beginDate,jdbcType=DATE&#125; (no time of the day), or#&#123;beginDate,jdbcType=TIMESTAMP&#125; (if you need to include the time of the day). And the Java parameter you want to apply should be of type: 123java.sql.Date (date without time)java.sql.Timestamp (timestamp)java.util.Date (date and time). the Greater Than/Equal Operator and the Less Than/Equal Operators:12ROWNUM &amp;gt;= 20ROWNUM &amp;lt;= 20 问题解决使用SpringMVC+Mybatis框架写项目的时候，在mapper里面的sql语句 123&lt;if test="updateTime != null"&gt; and update_time &amp;gt; #&#123;updateTime,jdbcType=TIMESTAMP&#125;&lt;/if&gt; 出错：There is no getter for property named &#39;updateTime&#39; in &#39;class java.util.Date&#39; 原因是：如果将and语句中的#｛属性｝写在if语句中，mybatis会去对象中从它的get方法中取值，而我之前是直接传递的值，并没有封装对象。解决办法： 1. 把updateTime需改为date 2. 把updateTime代表的参数封装到一个对象中]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot snippet]]></title>
    <url>%2F2016%2F08%2F14%2Fspringboot%20snippet%2F</url>
    <content type="text"><![CDATA[问题随记 Spring Boot通过Mybatis，使用mapper接口和xml配置sql，连接数据库 首先在配置文件application.properties 12345678910spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=***spring.datasource.password=***spring.datasource.driverClassName=com.mysql.jdbc.Driver#mybatis.typeAliasesPackage：为实体对象所在的包，跟数据库表一一对应#mybatis.mapperLocations：mapper文件的位置mybatis.typeAliasesPackage=com.xxx.modelmybatis.mapperLocations=classpath:mybatis/mapper/*Mapper.xml 在启动类Application.java中写上配置信息 12345678@SpringBootApplication@MapperScan("com.xxx.dao") // mybatis扫描路径，针对的是接口Mapper类public class DailyreportApplication&#123; public static void main(String[] args) &#123; SpringApplication.run(DailyreportApplication.class, args); &#125;&#125; mysql连接异常java.sql.SQLException: Value &#39;0000-00-00&#39; can not be represented as java.sql.Date 解决办法 jdbc:mysql://yourserver:3306/yourdatabase?zeroDateTimeBehavior=convertToNull]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[filter in servlet]]></title>
    <url>%2F2016%2F03%2F16%2Ffilter%20in%20servlet%2F</url>
    <content type="text"><![CDATA[A filter is an object that is invoked at the preprocessing and postprocessing of a request. It is mainly used to perform filtering tasks such as conversion, logging, compression, encryption and decryption, input validation etc. The servlet filter is pluggable, i.e. its entry is defined in the web.xml file, if we remove the entry of filter from the web.xml file, filter will be removed automatically and we don’t need to change the servlet. Usage of Filter recording all incoming requests logs the IP addresses of the computers from which the requests originate conversion data compression encryption and decryption input validation etc. Advantage of Fliter Filter is pluggable. One filter don’t have dependency onto another resource. Less Maintenance Filter API Filter For creating any filter, you must implement the Filter interface. Filter interface provides the life cycle methods for a filter. FilterChain The object of FilterChain is responsible to invoke the next filter or resource in the chain.This object is passed in the doFilter method of Filter interface. 123456789101112131415public class MyFilter implements Filter&#123; public void init(FilterConfig arg0) throws ServletException &#123;&#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123; PrintWriter out=resp.getWriter(); out.print("filter is invoked before"); chain.doFilter(req, resp);//sends request to next resource out.print("filter is invoked after"); &#125; public void destroy() &#123;&#125; &#125; FilterConfig]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event and Listen]]></title>
    <url>%2F2016%2F03%2F01%2FEvent%20and%20Listen%2F</url>
    <content type="text"><![CDATA[Events are basically occurrence of something. Changing the state of an object is known as an event.1We can perform some important tasks at the occurrence of these exceptions, such as counting total and current logged-in users, creating tables of the database at time of deploying the project, creating database connection object etc. Event classes ServletRequestEvent ServletContextEvent ServletRequestAttributeEvent ServletContextAttributeEvent HttpSessionEvent HttpSessionBindingEvent Event interfaces ServletRequestListener ServletRequestAttributeListener ServletContextListener ServletContextAttributeListener HttpSessionListener HttpSessionAttributeListener HttpSessionBindingListener HttpSessionActivationListener ServletContextEvent and ServletContextListener The ServletContextEvent is notified when web application is deployed on the server. If you want to perform some action at the time of deploying the web application such as creating database connection, creating all the tables of the project etc, you need to implement ServletContextListener interface and provide the implementation of its methods. Web application &gt; ServletContextEvent &gt; ServletContextListener HttpSessionEvent and HttpSessionListener The HttpSessionEvent is notified when session object is changed. The corresponding Listener interface for this event is HttpSessionListener. We can perform some operations at this event such as counting total and current logged-in users, maintaing a log of user details such as login time, logout time etc. session object &gt; HttpSessionEvent &gt; HttpSessionListener]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java code snippet]]></title>
    <url>%2F2016%2F02%2F16%2Fjava%20code%20snippet%2F</url>
    <content type="text"><![CDATA[base64ToByte123456789String string = "SmF2YWNvZGVnZWVrcw==";// Get bytes from stringbyte[] byteArray = Base64.decodeBase64(string.getBytes());// Print the decoded arraySystem.out.println(Arrays.toString(byteArray)); // Print the decoded string String decodedString = new String(byteArray);System.out.println(string + " = " + decodedString); TimeConvert1234567891011121314151617//date formatimport org.apache.commons.lang3.time.DateFormatUtils;String timeStr = DateFormatUtils.format(dateDate,"yyyy-MM-dd HH:mm:ss");Date dateTime = DateUtils.parseDate(dateTimeStr,"yyyy-MM-dd HH:mm:ss");SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");Date dateWithoutTime = sdf.parse(sdf.format(new Date()));//capitalize the first letter of wordString output = input.substring(0, 1).toUpperCase() + input.substring(1);//measure the time costlong start = System.nanoTime();//...long end = System.nanoTime();long used = end-start;System.out.println("used:"+TimeUnit.NANOSECONDS.toMillis(used)+" ms"); Lambda123456789101112131415161718192021222324252627282930//stream read database public void testStreamRead() &#123; oracleSqlSessionTemplate.select("xxxx.OracleMapper.getPersonInfos", new ResultHandler() &#123; @Override public void handleResult(ResultContext resultContext) &#123; PersonInfo personInfo = (PersonInfo) resultContext.getResultObject(); LOG.debug("result count:[&#123;&#125;],result info:[&#123;&#125;]", resultContext.getResultCount(), personInfo.getName()); &#125; &#125;); &#125; public void testStreamRead2() &#123; oracleSqlSessionTemplate.select("xxxx.OracleMapper.getPersonInfos", resultContext -&gt; &#123; PersonInfo personInfo = (PersonInfo) resultContext.getResultObject(); LOG.debug("result count:[&#123;&#125;],result info:[&#123;&#125;]", resultContext.getResultCount(), personInfo.getName()); &#125; ); &#125;//iterate listmyFinalList = new ArrayList&lt;&gt;();myListToParse.stream() .filter(elt -&gt; elt != null) .forEach(elt -&gt; myFinalList.add(doSomething(elt)));//prefermyFinalList = myListToParse.stream() .filter(elt -&gt; elt != null) .map(elt -&gt; doSomething(elt)) .collect(Collectors.toList()); threadnotify thread1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Shared&#123; synchronized void waitMethod() &#123; Thread t = Thread.currentThread(); System.out.println(t.getName()+" is releasing the lock and going to wait"); try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(t.getName()+" has been notified and acquired the lock back"); &#125; synchronized void notifyOneThread() &#123; Thread t = Thread.currentThread(); notify(); System.out.println(t.getName()+" has notified one thread waiting for this object lock"); &#125;&#125; public class MainClass &#123; public static void main(String[] args) &#123; final Shared s = new Shared(); //Thread t1 will be waiting for lock of object 's' Thread t1 = new Thread() &#123; @Override public void run() &#123; s.waitMethod(); &#125; &#125;; t1.start(); //Thread t2 will be waiting for lock of object 's' Thread t2 = new Thread() &#123; @Override public void run() &#123; s.waitMethod(); &#125; &#125;; t2.start(); //Thread t3 will be waiting for lock of object 's' Thread t3 = new Thread() &#123; @Override public void run() &#123; s.waitMethod(); &#125; &#125;; t3.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //Thread t4 will notify only one thread which is waiting for lock of object 's' Thread t4 = new Thread() &#123; @Override public void run() &#123; s.notifyOneThread(); &#125; &#125;; t4.start(); &#125; &#125; stop thread123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MyThread extends Thread&#123; //Initially setting the flag as true private volatile boolean flag = true; //This method will set flag as false public void stopRunning() &#123; flag = false; &#125; @Override public void run() &#123; //Keep the task in while loop //This will make thread continue to run until flag becomes false while (flag) &#123; System.out.println("I am running...."); &#125; System.out.println("Stopped Running...."); &#125;&#125; public class MainClass &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //call stopRunning() method whenever you want to stop a thread thread.stopRunning(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536class MyThread extends Thread&#123; @Override public void run() &#123; while (!Thread.interrupted()) &#123; System.out.println("I am running...."); &#125; System.out.println("Stopped Running....."); &#125;&#125; public class MainClass &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //interrupting the thread thread.interrupt(); &#125; &#125; try-catch-finally 不管有木有出现异常，finally块中代码都会执行** 当try和catch中有return时，finally仍然会执行 finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的； finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。 任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql snippet]]></title>
    <url>%2F2015%2F12%2F16%2Fmysql%20snippet%2F</url>
    <content type="text"><![CDATA[知识点 the size of blob column 1234 A BLOB can be 65535 bytes (64 KB) maximum.If you need more consider using:a MEDIUMBLOB for 16777215 bytes (16 MB)a LONGBLOB for 4294967295 bytes (4 GB). join sql string convert to timstamp SELECT STR_TO_DATE(&#39;2014-05-28 11:30:10&#39;,&#39;%Y-%m-%d %H:%i:%s&#39;); sql语句 IN 确定给定的值是否与子查询或列表中的值相匹配。in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。 1234567891011SELECT *FROM `user`WHERE `user`.id IN ( SELECT `order`.user_id FROM `order` ) 以上查询使用了in语句,in()只执行一次,它查出B表中的所有id字段并缓存起来.之后,检查A表的id是否与B表中的id相等,如果相等则将A表的记录加入结果集中,直到遍历完A表的所有记录。 可以看出,当B表数据较大时不适合使用in(),因为它会B表数据全部遍历一次. 如:A表有10000条记录,B表有1000000条记录,那么最多有可能遍历10000*1000000次,效率很差. 再如:A表有10000条记录,B表有100条记录,那么最多有可能遍历10000*100次,遍历次数大大减少,效率大大提升。 exists 指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。匹配上就将结果放入结果集中。 1select a.* from A a where exists(select 1 from B b where a.id=b.id) 以上查询使用了exists语句,exists()会执行A.length次,它并不缓存exists()结果集,因为exists()结果集的内容并不重要,重要的是结果集中是否有记录,如果有则返回true,没有则返回false。 当B表比A表数据大时适合使用exists(),因为它没有那么遍历操作,只需要再执行一次查询就行. 如:A表有10000条记录,B表有1000000条记录,那么exists()会执行10000次去判断A表中的id是否与B表中的id相等. 如:A表有10000条记录,B表有100000000条记录,那么exists()还是执行10000次,因为它只执行A.length次,可见B表数据越多,越适合exists()发挥效果. 再如:A表有10000条记录,B表有100条记录,那么exists()还是执行10000次,还不如使用in()遍历10000*100次,因为in()是在内存里遍历比较,而exists()需要查询数据库,我们都知道查询数据库所消耗的性能更高,而内存比较很快. where sql查询条件中where 1=1,1=2和1=0，这种写法，主要是为了拼凑动态的sql语句，如果使用不好会起到副作用的，是根据个人的一些习惯，是为了避免where 关键字后面的第一个词直接就是 “and”而导致语法错误，是为了后面附加and …方便程序逻辑处理用的。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>snippet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux command]]></title>
    <url>%2F2015%2F10%2F16%2Flinux%20command%2F</url>
    <content type="text"><![CDATA[Bash Scripting Tutorial for Beginners Bash Shell Scripting Definition Bash:Bourne-Again SHellBash is a command language interpreter. conclusionDo not be afraid to break things as that is perfectly normal. Troubleshooting and fixing code is perhaps the best booster for you to enhance your understanding of bash scripting and to improve your ability. Bash scripting Tutorial session kill seesion screen -X -S [session # you want to kill] quit PORT Check the listening ports Run any one of the following command: 123sudo lsof -i -P -n | grep LISTEN sudo netstat -tulpn | grep LISTENsudo nmap -sTU -O IP-address-Here checking remote system tcp 80 port status Telnet nc nmap123telnet myserver.com 80 nc -v myserver.com 80nmap myserver.com 80 tar c – Creates a new .tar archive file. x — to untar or extract a tar file v – Verbosely show the .tar file progress. f – File name type of the archive file. z — gzip archive file j — bz2 feature compress and create archive file t — to list the contents of tar archive file firewall check status : sudo ufw status enable firewall: 123$ sudo ufw enableCommand may disrupt existing ssh connections. Proceed with operation (y|n)? yFirewall is active and enabled on system startup disable firewall 12$ sudo ufw disableFirewall stopped and disabled on system startup]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 8]]></title>
    <url>%2F2015%2F09%2F01%2Fjava%208%20feature%2F</url>
    <content type="text"><![CDATA[forEach() method in Iterable interfacedefault and static methods in Interfaces Java 8 introduces the “Default Method” or (Defender methods) feature, which allows the developer to add new methods to the interfaces without breaking their existing implementation. It provides the flexibility to allow interface to define implementation which will use as the default in a situation where a concrete class fails to provide an implementation for that method. Functional Interfaces and Lambda ExpressionsFunctional Interfaces Being object oriented is not bad, but it brings a lot of verbosity to the program. Java 8 Functional Interfaces and Lambda Expressions help us in writing smaller and cleaner code by removing a lot of boiler-plate code. An interface with exactly one abstract method is called Functional Interface. @FunctionalInterface annotation is added so that we can mark an interface as functional interface. Some of the useful java 8 functional interfaces are Consumer, Supplier, Function and Predicate. Lambda Expression Objects are the base of java programming language and we can never have a function without an Object, that’s why Java language provide support for using lambda expressions only with functional interfaces. Lambda Expressions syntax is (argument) -&gt; (body). Java Stream API for Bulk Data Operations on CollectionsJava Time APICollection API improvementsConcurrency API improvementsJava IO improvementsMiscellaneous Core API improvements]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim command]]></title>
    <url>%2F2015%2F08%2F16%2Fvim%20command%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session tracking]]></title>
    <url>%2F2015%2F02%2F18%2Fsession%20tracking%2F</url>
    <content type="text"><![CDATA[session Session simply means a particular interval of time.Session Tracking is a way to maintain state (data) of an user. It is also known as session management in servlet. HTTP is stateless that means each request is considered as the new request. It is shown in the figure given below: There are four techniques used in Session tracking: Cookies Hidden Form Field URL Rewriting HttpSession cookie A cookie is a small piece of information that is persisted between the multiple client requests.A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. how cookie work type of cookie Non-persistent cookie It is valid for single session only. It is removed each time when user closes the browser. Persistent cookie It is valid for multiple session . It is not removed each time when user closes the browser. It is removed only if user logout or signout. Advantage Simplest technique of maintaining the state. Cookies are maintained at client side. Disadvantage It will not work if cookie is disabled from the browser. Only textual information can be set in Cookie object. HttpSession Interface An object of HttpSession can be used to perform two tasks: bind objects view and manipulate information about a session, such as the session identifier, creation time, and last accessed time.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java servlet]]></title>
    <url>%2F2015%2F02%2F16%2Fjava%20servlet%2F</url>
    <content type="text"><![CDATA[Web ApplicationHTML and HTTP HTML:HyperText Markup Language. HTTP:HyperText Transfer Protocol HTTP is the communication protocol between server and client. HTTP runs on top of TCP/IP communication protocol. Port numbers 0 to 1023 are reserved ports for well known services, for example 80 for HTTP, 443 for HTTPS, 21 for FTP etc. Java Servlet and JSPs are server side technologies to extend the capability of web servers by providing support for dynamic response and data persistence. Web Container When web container gets the request and if it’s for servlet then container creates two Objects HTTPServletRequest and HTTPServletResponse. Then it finds the correct servlet based on the URL and creates a thread for the request. Then it invokes the servlet service() method and based on the HTTP method service() method invokes doGet() or doPost() methods. Servlet methods generate the dynamic page and write it to response. Once servlet thread is complete, container converts the response to HTTP response and send it back to client. Some of the important work done by web container are: Communication Support – Container provides easy way of communication between web server and the servlets and JSPs. Because of container, we don’t need to build a server socket to listen for any request from web server, parse the request and generate response. All these important and complex tasks are done by container and all we need to focus is on our business logic for our applications. Lifecycle and Resource Management – Container takes care of managing the life cycle of servlet. Container takes care of loading the servlets into memory, initializing servlets, invoking servlet methods and destroying them. Container also provides utility like JNDI for resource pooling and management. Multithreading Support – Container creates new thread for every request to the servlet and when it’s processed the thread dies. So servlets are not initialized for each request and saves time and memory. JSP Support – JSPs doesn’t look like normal java classes and web container provides support for JSP. Every JSP in the application is compiled by container and converted to Servlet and then container manages them like other servlets. Miscellaneous Task – Web container manages the resource pool, does memory optimizations, run garbage collector, provides security configurations, support for multiple applications, hot deployment and several other tasks behind the scene that makes our life easier. Java Web Applications are packaged as Web Archive (WAR) and it has a defined structure. Servlet Servlet API Hierarchy Session ManagementWhat is a Session? HTTP protocol and Web Servers are stateless, what it means is that for web server every request is a new request to process and they can’t identify if it’s coming from client that has been sending request previously. Session is a conversional state between client and server and it can consists of multiple request and response between client and server. Since HTTP and Web Server both are stateless, the only way to maintain a session is when some unique information about the session (session id) is passed between server and client in every request and response. JSESSIONID Cookie When we use HttpServletRequest getSession() method and it creates a new request, it creates the new HttpSession object and also add a Cookie to the response object with name JSESSIONID and value as session id. This cookie is used to identify the HttpSession object in further requests from client. If the cookies are disabled at client side and we are using URL rewriting then this method uses the jsessionid value from the request URL to find the corresponding session. JSESSIONID cookie is used for session tracking, so we should not use it for our application purposes to avoid any session related issues. When a JSP resource is used, container automatically creates a session for it, so we can’t check if session is null to make sure if user has come through login page, so we are using session attribute to validate request. As we saw in last section that we can manage a session with HttpSession but if we disable the cookies in browser, it won’t work because server will not receive the JSESSIONID cookie from client. Cookie Basics a cookie is a small piece of data stored on the client-side which servers use when communicating with clients.They’re used to identify a client when sending a subsequent request. They can also be used for passing some data from one servlet to another.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux config]]></title>
    <url>%2F2015%2F01%2F16%2Flinux%20config%2F</url>
    <content type="text"><![CDATA[java config Use java -XshowSettings:properties to show the java.library.path (and others) value. native lib config /lib contain “essential” libraries that may be needed even in single-user (admin-only) mode and without /usr mounted /usr/lib are the libraries for the normal user-programs, that mostly can be found under /usr. /usr/local/lib are the libraries for locally installed programs and packages ie. things you’ve compiled and installed from source-packages yourself.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2015%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy Clean1$ hexo clean More info: Deployment]]></content>
  </entry>
</search>
